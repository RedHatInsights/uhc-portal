---
description: Unit testing rules and best practices
globs: src/**/*.test.ts, src/**/*.test.tsx, src/**/*.test.js, src/**/*.test.jsx
alwaysApply: false
---

- Follow the Arrange-Act-Assert pattern when writing unit tests
- Write descriptive test names that clearly describe what is being tested
- Test behavior, not implementation details
- Keep mocks simple and focused on the specific functionality being tested
- Avoid mocking child react components unless necessary for isolation
- Import React Testing Library items like `render` and `screen` from `~/testUtils`
- Use the the appropriate query using this order of priority: `getByRole`, `getByLabelText`, `getByPlaceholderText`, `getByText`, `getByDisplayValue`, `getByAltText`, `getByTitle`, `getByTestId`
- Use `waitFor` for async operations and state updates
- Use `user` returned from render for user interactions instead of `fireEvent`
- Test accessibility with `checkAccessibility` utility when appropriate
- Mock external dependencies and API calls consistently
- Use the custom `withState` utility for Redux testing
- Create meaningful test fixtures and move them to separate fixture files
- Use `jest.clearAllMocks()` in `beforeEach` or `afterEach` hooks
- Test error states and loading states in components
- Use `jest.spyOn` for mocking specific methods while preserving others
- Use `jest.mock` at the module level for consistent mocking
- Test custom hooks with `renderHook` when isolated testing is needed
- Use descriptive assertion messages when the test failure might be unclear
- Avoid try/catch blocks in unit tests
