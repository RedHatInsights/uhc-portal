---
description: Unit testing rules and best practices
globs: src/**/*.test.ts, src/**/*.test.tsx, src/**/*.test.js, src/**/*.test.jsx
alwaysApply: false
---

- Follow the Arrange-Act-Assert pattern when writing unit tests
- Write descriptive test names that clearly describe what is being tested
- Test behavior, not implementation details
- Keep mocks simple and focused on the specific functionality being tested
- Avoid mocking child react components unless necessary for isolation
- Import React Testing Library items like `render` and `screen` from `~/testUtils`
- Use the the appropriate query using this order of priority: `getByRole`, `getByLabelText`, `getByPlaceholderText`, `getByText`, `getByDisplayValue`, `getByAltText`, `getByTitle`, `getByTestId`
- Use `waitFor` for async operations and state updates
- Use `user` returned from render for user interactions instead of `fireEvent`
- Test accessibility with `checkAccessibility` utility when appropriate
- Mock external dependencies and API calls consistently
- Use the custom `withState` utility for Redux testing
- Create meaningful test fixtures and move them to separate fixture files
- Use `jest.clearAllMocks()` in `beforeEach` or `afterEach` hooks
- Test error states and loading states in components
- Use `jest.spyOn` for mocking specific methods while preserving others
- Use `jest.mock` at the module level for consistent mocking
- Test custom hooks with `renderHook` when isolated testing is needed
- Use descriptive assertion messages when the test failure might be unclear
- Avoid try/catch blocks in unit tests

## CRITICAL: Always Use Existing Test Utilities Before Creating New Mocks

**Before creating new mocks, check `~/testUtils` for existing utilities:**

- **Feature Gates**: ALWAYS use `mockUseFeatureGate([[FEATURE_NAME, true/false]])` from `~/testUtils`. NEVER manually mock `useFetchFeatureGate` or `useFeatureGate`.
  - Example: `mockUseFeatureGate([[MULTIREGION_PREVIEW_ENABLED, true]])`
  - Import: `import { mockUseFeatureGate } from '~/testUtils'`

- **Chrome/Red Hat Services**: Use `mockUseChrome(mockImpl?)` from `~/testUtils` instead of manually mocking `@redhat-cloud-services/frontend-components/useChrome`

- **Restricted Environment**: Use `mockRestrictedEnv(mockValue)` from `~/testUtils` instead of manually mocking restricted environment utilities

- **Redux State**: Use `withState(initialState)` from `~/testUtils` for Redux testing instead of manually creating stores

- **Formik/useFormState**: When mocking `useFormState` from `~/components/clusters/wizards/hooks`:
  1. Mock at module level: `jest.mock('~/components/clusters/wizards/hooks')`
  2. Import the hook: `import { useFormState } from '~/components/clusters/wizards/hooks'`
  3. Create typed mock at top of test suite: `const mockedUseFormState = useFormState as jest.MockedFunction<typeof useFormState>`
  4. Use `mockedUseFormState.mockReturnValue({ ... })` per test, NOT `(useFormStateModule.useFormState as jest.Mock)`
  5. See `src/components/clusters/common/Upgrades/UpgradeSettingsFieds.test.tsx` for reference pattern

**When writing tests:**
1. FIRST: Search `~/testUtils.tsx` for existing mocking utilities
2. SECOND: Check similar test files in the same directory for established patterns
3. THIRD: Only create new mocks if no existing utility exists
4. NEVER: Create manual mocks for hooks/utilities that have existing test utilities in `~/testUtils`
