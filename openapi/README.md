This directory captures snapshots of OpenAPI definitions from backends.
Run `make openapi` (at the root level) to grab new ones and generate src/types/ TypeScript from them.

# Lifecycle of OpenAPI definitions

OCM uses APIs from 2 places:

- Docs UI: https://api.stage.openshift.com/ (or production https://api.openshift.com/)  
  UI source: https://gitlab.cee.redhat.com/service/uhc-gateway/-/blob/master/portal/src/index.js  
  Data of covered APIs: https://api.stage.openshift.com/api (or production https://api.openshift.com/api).

- Docs UI: https://console.redhat.com/docs/api  
  UI source: https://github.com/RedHatInsights/api-frontend/  
  Data of covered APIs: https://console.redhat.com/api, https://console.redhat.com/config/main.yml

But the actual OpenAPI json files rendered by these UIs are not hosted in any centralized place;
they are served live each from its corresponding backend, and owned by the respective backend team e.g.
https://api.stage.openshift.com/api/clusters_mgmt/v1/openapi — served by clusters-service here:
https://gitlab.cee.redhat.com/service/uhc-clusters-service/-/blob/master/cmd/clusters-service/servecmd/apiserver/static.go

How the OpenAPI jsons get updated in backends varies... Details (as of this writing) on main ones:

- clusters-service (serving `clusters_mgmt` API) frequently implements APIs before they are documented.
  Source of truth are Go types in https://gitlab.cee.redhat.com/service/uhc-clusters-service/-/blob/master/pkg/api/

  (clusters-service does consume ocm-sdk-go types, but not for its server code, only for client calls to account-manager)

  Then (if not forgotten) they:

  1. Document it in custom DSL in https://github.com/openshift-online/ocm-api-model repo.
  2. This DSL is processed by https://github.com/openshift-online/ocm-api-metamodel tool.
     `metamodel generate openapi` emits both .json files, and encodes them as Go `[]byte` const.
  3. The generated OpenAPI JSON (and Go SDK code) get committed & released in https://github.com/openshift-online/ocm-sdk-go repo.
     (https://github.com/openshift-online/ocm-sdk-go/blob/main/clustersmgmt/v1/openapi.go,
     generated by https://github.com/openshift-online/ocm-api-metamodel/blob/92c5d3aaa3e15b39884e1f8a2e1f829ae266c8ac/pkg/generators/golang/openapi_generator.go#L225-L228)
  4. clusters-service bumps ocm-sdk-go version, and only then new OpenAPI is live on
     https://api.stage.openshift.com/api/clusters_mgmt/v1/openapi

  We don't want to wait for steps 2–4!
  `make openapi` pulls ocm-api-model repo and runs `metamodel` to produce fresh JSON.

- account-manager (serving `accounts_mgmt` and `authorizations` APIs) treats OpenAPI as source of truth:
  https://gitlab.cee.redhat.com/service/uhc-account-manager/-/tree/master/openapi
  They generate some of the server Go code from the OpenAPI, so we can expect the JSON they serve in staging to always be complete (neat!):
  https://api.stage.openshift.com/api/accounts_mgmt/v1/openapi

  What's confusing is the above process _also_ happens:  
  When people want to consume account-manager APIs via the Go SDK, they get added to ocm-api-model, processed by ocm-api-metamodel tool, and released in ocm-sdk-go.

  => The resulting 2nd OpenAPI JSON is not served anywhere.
  It's out of date, lower quality (e.g. less details on HTTP response code) and confusingly the types have different names.
  (account-manager does consume ocm-sdk-go but not for its own APIs, only for client calls to clusters-service)

# CI

In order to keep the OCMUI model types up to date, a pipeline has been provided. This can be found at `.github/check-api-pipeline.yml`. The pipeline consists of:

- Getting latest Open API contracts from public or private spaces.
- Checking for differences of files generated by the previous command, otherwise the pipeline just exits.
- Generating model types based on the Open API contracts.
- Pushing the changes and creating a merge request.

## How to keep patch file up to date

`manual_patches.patch` file contains `git diff` information after applying [manual patches](#warning-manual-patches). The recommended procedure for generating the patch is:

- Run `make openapi` and `yarn gen-types` normally
- Temporary commit the changes
- Apply the manual patches (do not commit anything)
- execute `git diff > openapi/manual_patches.patch`